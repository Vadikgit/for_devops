# Разработка RESTfull приложения для поиска друга для путешествия. 

6 основных CRUD операций, которые можно реализовать для такого сервиса:

## Создание пользователя и его профиля
Эта операция позволит зарегистрироваться в системе и создать базовый профиль пользователя.

**Метод**: `POST`

**Путь**: `/users`

**Данные запроса**:
```
{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "secure_password123",
  "country": "USA",
  "city": "New York"
}
```


## Поиск друзей
Эта операция позволит искать потенциальных друзей на основе различных критериев.

**Метод**: `GET`

**Путь**: `/friends/search`

**Данные запроса**:
```
?country=France&interests=cycling,hiking
```

## Подтверждение дружбы
После успешного поиска пользователь может подтвердить дружбу с найденным человеком.

**Метод**: `POST`

**Путь**: `/friendships`

**Данные запроса**:
```
{
  "user_id": 123,
  "friend_id": 456
}
```

## Получение списка друзей
Эта операция позволит получить список уже добавленных друзей пользователя.

**Метод**: `GET`

**Путь**: `/friends/{userId}`

**Параметры запроса**:
```
?limit=20&offset=0
```

## Обновление профиля пользователя
Пользователи могут изменять свои данные в личном кабинете.

**Метод**: `PATCH`

**Путь**: `/users/{userId}`

**Данные запроса**:
```
{
  "country": "Canada",
  "city": "Toronto"
}
```

## Удаление аккаунта пользователя
Эта операция позволяет полностью удалить учетную запись пользователя из системы.

**Метод**: `DELETE`

**Путь**: `/users/{userId}`


Что важно:

- Не забыть про обработку ошибок и валидацию входных данных.
- Все операции работают асинхронно для улучшения производительности.
- Использование кэширования для часто запрашиваемых данных (?).
- Для сложных операций, таких как поиск друзей, нужно использовать индексирование и оптимизацию запросов.

- Используем соответствующие HTTP методы для каждой операции.
- Приложение можно расширить, добавив дополнительные возможности, такие как обзор профиля, чат между пользователями или планирование совместных мероприятий.





# Запуск
## Запуск всего вместе
Для запуска достаточно иметь docker-compose.yml.

Переходим в корневую директорию проекта, где лежит файл docker-compose.yml. Запускаем

```
docker compose up
```

Дождавшись, когда все три контейнера поднимутся, открыть в браузере ``localhost:3000`` или вместо ``localhost`` ip контейнера клиента.

В целом, можно начинать тыкаться, но сначала стоит загрузить в базу данных некоторое количество записей о людях, их интересах и дружеских связях. Для этого можно открыть консоль psql в контейнере с базой данных:

```
docker exec -it <database container name> bash
psql -d travel_app
```

и скопировать туда содержимое файла server/app/sql/generate_entries.sql.

## Запуск сервисов по отдельности
Если нужно что-то протестить по отдельности, для поднятия базы данных можно использовать server/app/sql/docker-compose.yml. При этом, если сервер также будет запускаться отдельно через докер, нужно добавить в порты отображение ``5015:5015``, так как запросы к серверу будут идти через общую сеть контейнеров, параметры которой определяются в этом compose. Поэтому в нем же должны быть насстроены порты сервера.

В таком случае, при запуске сервера через докер используется его образ ``vadksen01/server-app``, при запуске указывается параметр --net и докер-сеть, созданная с компоусом базы данных, например:

```
docker run --net container:sql-postgres-1 -it --rm --name server-app-container server-app
```

Это нужно, чтобы база данных была связана с приложением сервера.


Если клиент запускается из докера, он должен при запуске публиковать порт, чтобы можно было отобразить фронт в браузере хоста через адрес ``localhost``.

```
docker run -p 3000:3000 -it --rm --name client-app-container client-app
```

Можно не публиковать порт, но тогда, чтобы отобразить в браузере хоста фронт, нужно указывать адрес докер контейнера, вместо ``localhost``.

Образы можно затребовать напрямую из хаба командами
```
docker pull vadksen01/server-app
docker pull vadksen01/client-app
```


## Пересоздание образов сервера и клиента
В директориях клиента и сервера лежат соответствующие Dockerfile. Их мы используем, для перегенерации образов при внесении изменений в исходники (или для изменения шагов построения самих образов).

Если внесли изменения, перестраиваем образ:

```
docker build -t vadksen01/server-app .
```

Публикуем:

```
docker push vadksen01/server-app
```

Аналогично с образом клиента ``vadksen01/client-app``.


## Как поднять SonarQube в Kubernetes?

1. Во-первых, нужно настроить kubectl.
2. Устанавливаем себе локально helm.
3. `kubectl create namespace sonarqube`
4. `helm repo add sonarqube https://SonarSource.github.io/helm-chart-sonarqube`
5. `helm repo update`
6. `helm install --namespace sonarqube sonarqube -f sonarqube-values.yaml sonarqube/sonarqube`
   + Если нужно будет обновить: `helm upgrade -f sonarqube-values.yaml -n sonarqube sonarqube sonarqube/sonarqube`
7. Для подключения лучше всего настроить публичный IP. Но можно и пробросить порт: `kubectl port-forward sonarqube-sonarqube-0 9000:9000 -n sonarqube --address '0.0.0.0'`
   + Узнать имя pod'a: `kubectl get pods -n sonarqube -l "app=sonarqube,release=sonarqube" -o jsonpath="{.items[0].metadata.name}"`
   + Чтобы узнать `CLUSTER-IP`: `kubectl get csv -n sonarqube`.
8. Генерируем Token для доступа:
   + Переходим в SonarQube `http://localhost:9000`.
   + `User` -> `My Account` -> `Security` -> Создаем токен и сохраняем.
9.  Ещё ~~полезно~~ будет отключить `Coverage`, чтобы анализ не выдавал ошибку, т.к. по дефолту он требует 80% тестового покрытия кода:
      + Переходим в SonarQube `http://localhost:9000`.
      + `Administration` -> `Analysos Scope` -> `Coverage Exclusions`.
      + Прописываем в `values`: `**/*.*`
10. Пример переменной `SONAR_HOST_URL`: `http://10.95.145.10:9000`.

P.S.: Главное пофиксить все ошибки, которые вам выдавал SonarQube, иначе будет кидать status: `Failed`.  
  

## Как настроить CI/CD?
1. Достаем переменные окружения и сохраняем на GitLab в репозитории `Settings` -> `CI/CD` -> `Variables` (отключаем **Protected** и включаем **Masked**):
   + K8S_BASE_URL: `kubectl config view --minify -o jsonpath='.clusters[0].cluster.server'`
   + K8S_CA_DATA: `kuberctl config view --raw -o jsonpath='{.clusters[0].cluster.certificate-authority-data}'`
   + K8S_USER_TOKEN: `kubectl create token default`
2. Дальше настраиваем ваши `.yml` файлы для кубера, пример у меня в [./deployment](./deployment). Ну и как в 3 ЛР: `kubectl apply -f {FILE_NAME}.yml`
3. Настраиваем workflow в Github Actions.
4. После этого все должно автоматически тестировать, билдиться, анализироваться, пушить образы и деплоить.






